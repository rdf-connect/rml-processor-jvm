/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.function.Consumer;
import java.util.logging.Logger;

import org.apache.jena.riot.Lang;
import org.apache.jena.riot.RDFDataMgr;

import com.google.protobuf.ByteString;

import be.ugent.idlab.knows.functions.agent.Agent;
import be.ugent.rml.Executor;
import be.ugent.rml.StrictMode;
import be.ugent.rml.conformer.MappingConformer;
import be.ugent.rml.records.RecordsFactory;
import be.ugent.rml.store.QuadStore;
import be.ugent.rml.store.QuadStoreFactory;
import be.ugent.rml.term.NamedNode;
import io.github.rdfc.IReader;
import io.github.rdfc.IWriter;
import io.github.rdfc.Processor;

public class App extends Processor<App.Args> {
    final static String DEFAULT_BASE_IRI = "http://example.com/base/";

    private List<QuadStore> rmlStores = new ArrayList<>();
    private RecordsFactory recordsFactory;
    private String baseIRI = DEFAULT_BASE_IRI;
    private StrictMode strictMode = StrictMode.BEST_EFFORT;
    private Map<String, CacheReader> readers = new HashMap<>();
    private Agent functionAgent = null;
    private Consumer<Void> closeCb;

    private Set<String> openReader = new HashSet<>();
    private Set<String> notReadyReaders = new HashSet<>();

    public App(App.Args args, Logger logger) throws Exception {
        super(args, logger);

        this.recordsFactory = new MyRecordsFactory(readers);

        // this.functionAgent = AgentFactory.createFromFnO(
        // "fno/functions_idlab.ttl",
        // "fno/functions_idlab_classes_java_mapping.ttl",
        // "fno_idlab_old/functions_idlab.ttl",
        // "fno_idlab_old/functions_idlab_classes_java_mapping.ttl",
        // "grel_java_mapping.ttl",
        // "functions_grel.ttl");
        logger.info("Hello App!");
        logger.fine("Hello App!");
    }

    Executor engine(QuadStore rmlStore) throws Exception {
        return new Executor(rmlStore, this.recordsFactory, null, this.baseIRI, this.strictMode,
                this.functionAgent);
    }

    private void executeOnce() throws Exception {
        System.out.println("Checking execute once (really" + this.notReadyReaders.isEmpty() + ")");
        if (!this.notReadyReaders.isEmpty()) {
            return;
        }

        for (QuadStore rmlStore : this.rmlStores) {
            var engine = this.engine(rmlStore);
            System.out.println("Got engine");
            var maps = engine.execute(null, true, null);

            System.out.println("got mappings");
            if (this.arguments.defaultTarget != null) {
                System.out.println("default target is present");
                var store = maps.get(new NamedNode("rmlmapper://default.store"));
                StringWriter out = new StringWriter();

                store.write(out, "turtle");
                String trig = out.toString();
                System.out.println("Got Quads " + trig);
                this.arguments.defaultTarget.msg(ByteString.copyFromUtf8(trig));
            }

            for (var target : this.arguments.targets) {
                var id = target.mappingId != null ? target.mappingId : target.writer.id();
                var store = maps.get(new NamedNode(id));
                System.out.println("target " + id + " is found " + store != null);
                if (store != null) {
                    StringWriter out = new StringWriter();

                    store.write(out, "turtle");
                    String trig = out.toString();

                    System.out.println(trig);
                    target.writer.msg(ByteString.copyFromUtf8(trig));
                }
            }
        }
    }

    private void convertToRml(QuadStore store) throws Exception {
        MappingConformer conformer = new MappingConformer(store, new HashMap<>());
        try {
            boolean conversionNeeded = conformer.conform();
            if (conversionNeeded) {
                System.out.println("Conversion to RML was needed.");
            }
        } catch (Exception e) {
            System.out.println("Failed to make mapping file conformant to RML spec.");
            throw e; // rethrow the exception to be caught by the test
        }
    }

    static class Source {
        public IReader reader;
        public String mappingId = null;
        public boolean triggers = false;
    }

    static class Target {
        public IWriter writer;
        public String mappingId = null;
    }

    static class Args {
        public IReader mappings;
        // public boolean waitForMappingClose;
        public List<Source> sources;
        public List<Target> targets;
        public IWriter defaultTarget = null;
    }

    @Override
    public void init(Consumer<Void> callback) {
        System.out.println("Inside loader: " + this.getClass().getClassLoader());
        System.out.println("Thread loader: " + Thread.currentThread().getContextClassLoader());

        this.openReader.add(this.arguments.mappings.id());
        this.arguments.mappings.buffers().on(buffer -> {
            if (buffer.isPresent()) {
                InputStream inputStream = new ByteArrayInputStream(buffer.get().toByteArray());
                try {
                    QuadStore rmlStore = QuadStoreFactory.read(inputStream);
                    convertToRml(rmlStore);
                    this.rmlStores.add(rmlStore);
                } catch (Exception e) {
                }
            } else {
                this.close(this.arguments.mappings.id());
            }
        });

        for (var input : this.arguments.sources) {
            this.setupSource(input);
        }

        callback.accept(null);
    }

    private void setupSource(Source source) {

        System.out.println("Setup source " + source.reader.id());
        this.notReadyReaders.add(source.reader.id());
        this.openReader.add(source.reader.id());

        var id = source.mappingId == null ? source.reader.id() : source.mappingId;
        this.readers.put(id, new CacheReader(source.reader));

        source.reader.buffers().on(buf -> {
            if (buf.isEmpty()) {
                this.close(source.reader.id());
            } else {
                this.notReadyReaders.remove(source.reader.id());
                System.out.println("Got data message from " + source.reader.id() + " I trigger " + source.triggers);
                if (source.triggers) {
                    try {
                        this.executeOnce();
                    } catch (Exception e) {
                        System.out.println("Execute Once failed " + e);
                    }
                }
            }
        });
    }

    private void close(String id) {
        System.out.println("Closing " + id);
        this.openReader.remove(id);
        if (this.openReader.isEmpty()) {
            System.out.println("everything is empty");
            for (var writer : this.arguments.targets) {
                writer.writer.close();
            }

            this.closeCb.accept(null);
        }
    }

    @Override
    public void transform(Consumer<Void> callback) {
        callback.accept(null);
    }

    @Override
    public void produce(Consumer<Void> callback) {
        this.closeCb = callback;
    }
}
