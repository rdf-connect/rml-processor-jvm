/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.HashSet;
import java.util.logging.Logger;

import com.google.protobuf.ByteString;

import be.ugent.idlab.knows.functions.agent.Agent;
import be.ugent.idlab.knows.functions.agent.AgentFactory;
import be.ugent.rml.Executor;
import be.ugent.rml.StrictMode;
import be.ugent.rml.conformer.MappingConformer;
import be.ugent.rml.records.RecordsFactory;
import be.ugent.rml.store.QuadStore;
import be.ugent.rml.store.QuadStoreFactory;
import be.ugent.rml.term.NamedNode;
import be.ugent.rml.term.Term;
import io.github.rdfc.IReader;
import io.github.rdfc.IWriter;
import io.github.rdfc.Processor;

public class App extends Processor<App.Args> {
    final static String DEFAULT_BASE_IRI = "http://example.com/base/";

    private List<QuadStore> rmlStores = new ArrayList<>();
    private RecordsFactory recordsFactory;
    private StrictMode strictMode = StrictMode.BEST_EFFORT;
    private Map<String, CacheReader> readers = new HashMap<>();

    // cache the function agent for all incoming requests
    private Agent functionAgent = null;
    // remember what to do, once all input streams are closed
    private CompletableFuture<Void> closeFut;

    // this indicates whether or not a trigger is fired but failed to resolve as not
    // all sources are ready yet
    private boolean wantsToExecute = false;

    private Set<String> openReader = new HashSet<>();
    private Set<String> notReadyReaders = new HashSet<>();

    public App(App.Args args, Logger logger) throws Exception {
        super(args, logger);

        this.functionAgent = AgentFactory.createFromFnO(
                "fno/functions_idlab.ttl", "fno/functions_idlab_classes_java_mapping.ttl",
                "fno_idlab_old/functions_idlab.ttl", "fno_idlab_old/functions_idlab_classes_java_mapping.ttl",
                "functions_grel.ttl",
                "grel_java_mapping.ttl");

        this.recordsFactory = new MyRecordsFactory(readers);
    }

    Executor engine(QuadStore rmlStore) throws Exception {
        return new Executor(rmlStore, this.recordsFactory, null, this.arguments.baseIRI, this.strictMode,
                this.functionAgent);
    }

    /**
     * Tries to execute the current configuration (found mapping files).
     * If the configuration allows, the RML mapping will be executed with the data
     * and send the correct triples to the correct output channel.
     * 
     * @return the future that resolves when each output is succesfully sent.
     * @note Please await this future before starting a new execution to relieve the
     *       backpressure.
     */
    private CompletableFuture<Void> executeOnce() {
        System.out.println("Execute Once");

        if (this.arguments.waitForMappingClose) {
            // Still waiting for mapping close
            this.logger.fine("Wants to execute, but the mapping channel is not yet closed");
            this.wantsToExecute = true;
            return CompletableFuture.completedFuture(null);
        }

        if (!this.notReadyReaders.isEmpty()) {
            this.logger.fine(
                    "Wants to execute, but not all channels have sent data, still missing: "
                            + this.notReadyReaders);
            // A triggered data reader wants to map, but not all sources are ready yet
            this.wantsToExecute = true;
            return CompletableFuture.completedFuture(null);
        }

        this.logger.fine("starting to execute on " + this.rmlStores.size() + " stores");

        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();
        System.out.println("Awaiting " + this.arguments.targets.size() + " writes");

        for (QuadStore rmlStore : this.rmlStores) {
            try {
                var engine = this.engine(rmlStore);
                this.logger.fine("got engine");
                var maps = engine.execute(null, true, null);
                this.logger.fine("got maps " + maps.keySet());

                this.outputDefaultTarget(maps, futures);

                for (var target : this.arguments.targets) {
                    outputToTarget(maps, target, futures);
                }

            } catch (Exception e) {
                System.out.println("error happened during mapping");
                this.logger.severe("error happened during mapping: " + e.getMessage());
                e.printStackTrace();
            }
        }

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).thenAccept(_void -> {
            System.out.println("All settled!");
        });
    }

    private void outputToTarget(Map<Term, QuadStore> maps, Target target, ArrayList<CompletableFuture<Void>> futures)
            throws Exception {
        var id = target.mappingId != null ? target.mappingId : target.writer.id();
        var store = maps.get(new NamedNode(id));
        this.logger.fine("target " + id + " is found " + (store != null));
        if (store != null) {
            ByteArrayOutputStream out = new ByteArrayOutputStream();

            store.write(out, target.format);
            String trig = out.toString(StandardCharsets.UTF_8);

            futures.add(target.writer.chunk(ByteString.copyFromUtf8(trig)));
        }
    }

    private void outputDefaultTarget(Map<Term, QuadStore> maps,
            ArrayList<CompletableFuture<Void>> futures) throws Exception {
        if (this.arguments.defaultTarget != null) {
            this.logger.fine("default target is present");

            var store = maps.get(new NamedNode("rmlmapper://default.store"));

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            store.write(out, this.arguments.defaultTarget.format);

            String trig = out.toString(StandardCharsets.UTF_8);
            futures.add(
                    this.arguments.defaultTarget.writer.chunk(ByteString.copyFromUtf8(trig)));
        }
    }

    private void convertToRml(QuadStore store) throws Exception {
        MappingConformer conformer = new MappingConformer(store, new HashMap<>());
        try {
            boolean conversionNeeded = conformer.conform();
            if (conversionNeeded) {
                this.logger.fine("Conversion to RML was needed.");
            }
        } catch (Exception e) {
            this.logger.severe("Failed to make mapping file conformant to RML spec.");
            throw e; // rethrow the exception to be caught by the test
        }
    }

    static class Source {
        public IReader reader;
        public String mappingId = null;
        public boolean triggers = false;
    }

    static class Target {
        public IWriter writer;
        public String mappingId = null;
        public String format = "turtle";
    }

    static class Args {
        public IReader mappings;
        public boolean waitForMappingClose = false;
        public List<Source> sources;
        public List<Target> targets;
        public Target defaultTarget = null;
        public String baseIRI = DEFAULT_BASE_IRI;
    }

    @Override
    public CompletableFuture<?> init() {
        this.openReader.add(this.arguments.mappings.id());
        this.notReadyReaders.add(this.arguments.mappings.id());

        for (var input : this.arguments.sources) {
            this.setupSource(input);
        }

        return CompletableFuture.completedFuture(null);
    }

    private void setupSource(Source source) {
        this.logger.fine("Setup source " + source.reader.id());

        this.notReadyReaders.add(source.reader.id());
        this.openReader.add(source.reader.id());

        var id = source.mappingId == null ? source.reader.id() : source.mappingId;
        this.readers.put(id, new CacheReader(source.reader));

        source.reader.buffers().on(buf -> {
            this.notReadyReaders.remove(source.reader.id());
            this.logger.fine("Got data message from " + source.reader.id() + " I trigger " + source.triggers);

            if (source.triggers) {
                return this.executeOnce();
            } else {
                // This source doesn't trigger, but a triggering source wanted to trigger
                // already
                if (this.wantsToExecute) {
                    this.wantsToExecute = false;
                    return this.executeOnce();
                }
            }
            return CompletableFuture.completedFuture(null);
        }).thenAccept(_void -> {
            this.close(source.reader.id());
        });
    }

    private void close(String id) {
        this.logger.fine("Closing id " + id);
        this.openReader.remove(id);
        if (this.openReader.isEmpty()) {
            this.logger.fine("Starting shutdown");

            List<CompletableFuture<Void>> closingFutures = new ArrayList<>();

            if (this.arguments.defaultTarget != null) {
                closingFutures.add(this.arguments.defaultTarget.writer.close());
            }

            for (var writer : this.arguments.targets) {
                closingFutures.add(writer.writer.close());
            }

            CompletableFuture.allOf(closingFutures.toArray(new CompletableFuture[0])).thenAccept(_void -> {
                this.closeFut.complete(null);
            });
        }
    }

    @Override
    public CompletableFuture<?> transform() {
        this.logger.info("Transforming!");
        return this.arguments.mappings.buffers().on(buffer -> {
            this.logger.fine("Got RML mapping!");
            InputStream inputStream = new ByteArrayInputStream(buffer.toByteArray());
            try {
                QuadStore rmlStore = QuadStoreFactory.read(inputStream);
                convertToRml(rmlStore);
                this.rmlStores.add(rmlStore);
            } catch (Exception e) {
                e.printStackTrace();
            }

            this.notReadyReaders.remove(this.arguments.mappings.id());
            if (this.wantsToExecute) {
                return this.executeOnce();
            } else {
                return CompletableFuture.completedFuture(null);
            }
        }).thenCompose(_void -> {
            this.logger.fine("No more mapping files coming in");
            if (this.arguments.waitForMappingClose) {
                this.logger.fine("But there was already data, so let's map them now");
                this.arguments.waitForMappingClose = false;
                return this.executeOnce();
            } else {
                return CompletableFuture.completedFuture(null);
            }
        }).thenAccept(_void -> {
            this.logger.fine("Closing rml stream!");
            this.close(this.arguments.mappings.id());
        });
    }

    @Override
    public CompletableFuture<?> produce() {
        this.closeFut = new CompletableFuture<>();
        return this.closeFut;
    }
}
