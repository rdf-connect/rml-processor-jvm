/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.function.Consumer;
import java.util.logging.Logger;

import com.google.protobuf.ByteString;

import be.ugent.idlab.knows.functions.agent.Agent;
import be.ugent.idlab.knows.functions.agent.AgentFactory;
import be.ugent.rml.Executor;
import be.ugent.rml.StrictMode;
import be.ugent.rml.conformer.MappingConformer;
import be.ugent.rml.records.RecordsFactory;
import be.ugent.rml.store.QuadStore;
import be.ugent.rml.store.QuadStoreFactory;
import be.ugent.rml.term.NamedNode;
import io.github.rdfc.IReader;
import io.github.rdfc.IWriter;
import io.github.rdfc.Processor;

public class App extends Processor<App.Args> {
    final static String DEFAULT_BASE_IRI = "http://example.com/base/";

    private List<QuadStore> rmlStores = new ArrayList<>();
    private RecordsFactory recordsFactory;
    private StrictMode strictMode = StrictMode.BEST_EFFORT;
    private Map<String, CacheReader> readers = new HashMap<>();

    // cache the function agent for all incoming requests
    private Agent functionAgent = null;
    // remember what to do, once all input streams are closed
    private Consumer<Void> closeCb;

    // this indicates whether or not a trigger is fired but failed to resolve as not
    // all sources are ready yet
    private boolean wantsToExecute = false;

    private Set<String> openReader = new HashSet<>();
    private Set<String> notReadyReaders = new HashSet<>();

    public App(App.Args args, Logger logger) throws Exception {
        super(args, logger);

        this.functionAgent = AgentFactory.createFromFnO(
                "fno/functions_idlab.ttl", "fno/functions_idlab_classes_java_mapping.ttl",
                "fno_idlab_old/functions_idlab.ttl", "fno_idlab_old/functions_idlab_classes_java_mapping.ttl",
                "functions_grel.ttl",
                "grel_java_mapping.ttl");

        this.recordsFactory = new MyRecordsFactory(readers);
    }

    Executor engine(QuadStore rmlStore) throws Exception {
        return new Executor(rmlStore, this.recordsFactory, null, this.arguments.baseIRI, this.strictMode,
                this.functionAgent);
    }

    private void executeOnce() {
        if (this.arguments.waitForMappingClose) {
            // Still waiting for mapping close
            this.logger.fine("Wants to execute, but the mapping channel is not yet closed");
            this.wantsToExecute = true;
            return;
        }

        if (!this.notReadyReaders.isEmpty()) {
            this.logger.fine(
                    "Wants to execute, but the not all channels have sent data, still missing: "
                            + this.notReadyReaders);
            // A triggered data reader wants to map, but not all sources are ready yet
            this.wantsToExecute = true;
            return;
        }

        this.logger.fine("starting to execute on " + this.rmlStores.size() + " stores");

        for (QuadStore rmlStore : this.rmlStores) {
            try {
                var engine = this.engine(rmlStore);
                this.logger.fine("got engine");
                var maps = engine.execute(null, true, null);
                this.logger.fine("got maps " + maps.keySet());

                if (this.arguments.defaultTarget != null) {
                    this.logger.fine("default target is present");

                    var store = maps.get(new NamedNode("rmlmapper://default.store"));
                    StringWriter out = new StringWriter();

                    store.write(out, this.arguments.defaultTarget.format);
                    String trig = out.toString();

                    this.logger.fine("writing " + trig);
                    this.arguments.defaultTarget.writer.msg(ByteString.copyFromUtf8(trig));
                }

                for (var target : this.arguments.targets) {
                    var id = target.mappingId != null ? target.mappingId : target.writer.id();
                    var store = maps.get(new NamedNode(id));
                    this.logger.fine("target " + id + " is found " + (store != null));
                    if (store != null) {
                        StringWriter out = new StringWriter();

                        store.write(out, target.format);
                        String trig = out.toString();

                        this.logger.fine("writing " + trig);
                        target.writer.msg(ByteString.copyFromUtf8(trig));
                    }
                }
            } catch (Exception e) {
                System.out.println("error happened during mapping");
                this.logger.severe("error happened during mapping");
                e.printStackTrace();
            }
        }
    }

    private void convertToRml(QuadStore store) throws Exception {
        MappingConformer conformer = new MappingConformer(store, new HashMap<>());
        try {
            boolean conversionNeeded = conformer.conform();
            if (conversionNeeded) {
                this.logger.fine("Conversion to RML was needed.");
            }
        } catch (Exception e) {
            this.logger.severe("Failed to make mapping file conformant to RML spec.");
            throw e; // rethrow the exception to be caught by the test
        }
    }

    static class Source {
        public IReader reader;
        public String mappingId = null;
        public boolean triggers = false;
    }

    static class Target {
        public IWriter writer;
        public String mappingId = null;
        public String format = "turtle";
    }

    static class Args {
        public IReader mappings;
        public boolean waitForMappingClose = false;
        public List<Source> sources;
        public List<Target> targets;
        public Target defaultTarget = null;
        public String baseIRI = DEFAULT_BASE_IRI;
    }

    @Override
    public void init(Consumer<Void> callback) {
        this.openReader.add(this.arguments.mappings.id());

        this.notReadyReaders.add(this.arguments.mappings.id());
        this.arguments.mappings.buffers().on(buffer -> {
            if (buffer.isPresent()) {
                this.logger.fine("Got rml mapping!");
                InputStream inputStream = new ByteArrayInputStream(buffer.get().toByteArray());
                try {
                    QuadStore rmlStore = QuadStoreFactory.read(inputStream);
                    convertToRml(rmlStore);
                    this.rmlStores.add(rmlStore);
                } catch (Exception e) {
                    e.printStackTrace();
                }

                this.notReadyReaders.remove(this.arguments.mappings.id());
                if (this.wantsToExecute) {
                    this.executeOnce();
                }
            } else {
                this.logger.fine("Closing rml stream!");
                this.close(this.arguments.mappings.id());

                if (this.arguments.waitForMappingClose) {
                    this.arguments.waitForMappingClose = false;
                    this.executeOnce();
                }
            }
        });

        for (var input : this.arguments.sources) {
            this.setupSource(input);
        }

        callback.accept(null);
    }

    private void setupSource(Source source) {
        this.logger.fine("Setup source " + source.reader.id());

        this.notReadyReaders.add(source.reader.id());
        this.openReader.add(source.reader.id());

        var id = source.mappingId == null ? source.reader.id() : source.mappingId;
        this.readers.put(id, new CacheReader(source.reader));

        source.reader.buffers().on(buf -> {
            if (buf.isEmpty()) {
                this.close(source.reader.id());
            } else {
                this.notReadyReaders.remove(source.reader.id());

                this.logger.fine("Got data message from " + source.reader.id() + " I trigger " + source.triggers);
                if (source.triggers) {
                    this.executeOnce();
                } else {
                    // This source doesn't trigger, but a triggering source wanted to trigger
                    // already
                    if (this.wantsToExecute) {
                        this.wantsToExecute = false;
                        this.executeOnce();
                    }

                }
            }
        });
    }

    private void close(String id) {
        this.logger.fine("Closing id " + id);
        this.openReader.remove(id);
        if (this.openReader.isEmpty()) {
            this.logger.fine("Starting shutdown");

            if (this.arguments.defaultTarget != null) {
                this.arguments.defaultTarget.writer.close();
            }

            for (var writer : this.arguments.targets) {
                writer.writer.close();
            }

            this.closeCb.accept(null);
        }
    }

    @Override
    public void transform(Consumer<Void> callback) {
        callback.accept(null);
    }

    @Override
    public void produce(Consumer<Void> callback) {
        this.closeCb = callback;
    }
}
